## AOP IOC

#### 为什么要用 Spring ？

我们写代码，不仅仅是要能实现功能，实现完了以后我们还得对写过的代码 **维护**。

如果我们的代码写得很烂，那**维护**的成本就很高。

- **维护**是在做什么呢？

1. 出了问题需要找到是哪块的代码有问题。
2. 在原有的基础上加入一些新的功能（也就是所谓的迭代）。



- 当面对重复的/繁琐的非业务代码：

1. 如果程序出了问题，我们得看吧？谁也保证不了重复的代码就没有问题。
2. 我们要想加一个新的功能，还得按原来的方式写吧？代码量会越来越多，越来越多….



这就好比：

我们的JDBC写得好好的，运行的效率也是杠杠的。但是JDBC需要我们 **自己处理** 的细节太多了，我们需要在里边添加各种 **重复** 的代码。

而使用ORM框架，那么我们就可以更加 **专注** 去实现本身的业务，ORM框架把**重复**的代码都屏蔽掉，代码维护起来就比JDBC要方便。



- Spring 最核心的 AOP IOC 就可以解决维护问题。

1. Spring IOC 解决的是 **对象管理和对象依赖的问题**。

2. Spring AOP 解决的是 **非业务代码抽取的问题**。



#### Spring IOC

本来我们的对象都是 `new` 出来的，而我们如果使用 `Spring`  则把对象交给 **IOC容器** 来管理。

- **IOC容器** 是什么？

1. 我们可以理解为是一个**工厂**，我们把对象都交由这个 **工厂** 来管理，包括 **对象的创建** 和 **对象之间的依赖关系** 等。

2. 等我们要用到对象的时候，就从这个 **工厂** 里边取出来。



- **控制反转** 是什么？

1. 本来是 **由我们自己** `new`出来的对象，现在交给了IOC容器。把这个对象的 **控制权** 给 **别人** 了。
2. **控制反转** 更多的是一种 **思想** 或者说是 **设计模式**，把原本由自己掌控的事交给别人来处理。



- **依赖注入**是什么？

1. 更多指的是控制反转这个思想的**实现方式**。

2. 对象无需**自行**创建或管理它们的依赖关系，依赖关系将被**自动注入**到需要它们的对象当中去。



简而言之，控制反转 依赖注入：本来对象都是由我们自己 `new`出来的，现在把对象的 创建权限 和 对象之间的依赖关系 都交给 **IOC容器**来管理。



- 使用 **IOC** 的好处：

1. 将对象集中统一管理，便于修改

2. 降低耦合度： 调用方无需自己组装，也无需关心对象的实现，直接从**IOC容器**取就好了



#### IOC需要做什么？

1. 我们在使用 Spring 的时候，首先我们要学习的就是 **怎么把** 对象交给 **IOC容器** 管理。

Spring提供了四种方式：

- 注解
- XML
- JavaConfig
- 基于Groovy DSL配置

总的来说：我们以 **XML配置+注解** 来装配Bean比较多，其中 **注解** 这种方式占大部分。



2. 把对象放到 IOC容器 以后，我们需要把对象之间的依赖告诉 Spring，让它来帮我们解决掉对象的依赖关系。

- 一般来说我们会通过 **构造器** 或者 **属性**(setting方法) 的方式来注入对象的依赖。

举个例子：日常开发中，我们很多时候用 `@Component` 注解标识将对象放到 **IOC容器** 中，用`@Autowired`注解将对象注入。

```java
// Component ： 把 UserServerice 对象交给 IOC容器 管理
@Component
public class UserService {
		private UserDao userDao;
		
  	// Autowired : UserService 对象在 userDao 引用，用@Autowired 注入userDao对象
		@Autowired
		public void setUserDao (UserDao userDao) {
				this.userDao = userDao;
		}
}
```



#### Spring AOP

Aspect Object Programming，面向切面编程。

- 主要做的事：

1. 把重复的代码抽取。
2. 在运行的时候往业务方法上 **动态植入** 切面类代码。



