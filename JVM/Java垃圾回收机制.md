## Java垃圾回收机制

#### 判断用户是否可用算法

- 引用计数算法
  - 给对象一个引用计数器 refCount。
  - 每有一个对象引用它，计数器加1，当 refCount = 0 的时候，表示对象不再可用
  - 缺点：很难解决循环引用问题
- 可达性分析算法
  - 从GC Roots 开始向下搜索，连接的路径为引用链
  - GC Roots 不可达的对象被判为不可用



#### 垃圾回收算法

- 标记-清除算法

  - 描述
    - 标记阶段：标记处所有需要回收的对象
    - 清除阶段：标记完成后，统一回收所有被标记的对象

  - 缺点
    - 效率不高：标记和清除两个过程效率都不高
    - 空间问题：产生大量不连续的内存碎片，进而无法容纳大对象提早触发另一次 GC

- 复制算法

  - 描述
    - 将可用内存分为容量大小相等的两块，每次只使用其中一块
    - 当一块用完，就将存活着的对象复制到另一块，然后将这块全部内存清理掉
  - 优点
    - 不会产生不连续的内存碎片
    - 提高效率
    - 回收：每次都是对整个半区进行回收
    - 分配：分配时也不用考虑内存碎片问题，只要移动堆顶指针，按顺序分配内存即可

  - 缺点
    - 可用内存缩小为原来的一半了，适合 GC 过后只有少量存活的新生代，可以根据实际情况，将内存块大小比例适当调整
    - 如果存活对象数量比较大，复制性能会变得很差

- 标记-整理算法

  - 描述
    - 标记过程与标记-清楚算法一样
    - 标记完成后，将存活对象向一端移动，然后直接清理掉边界以外的内存
  - 优点
    - 不会产生内存碎片
    - 不需要浪费额外的空间进行分配担保
  - 缺点
    - 整理阶段存在效率问题，适合老年代这种垃圾回收频率不是很高的场景

- 分代收集算法

  - 当前商业虚拟机都采用该算法
  - 新生代：复制算法（CG后只有少量的对象存活）
  - 老年代：标记-整理算法 或者 标记-清理算法（GC 后对象存活率高）



#### 垃圾回收器

- Serial收集器

  - 特点
    - 串行化：在垃圾回收时，必须赞同其他所有工作线程，知道收集结束，`Stop The World`
    - 在单CPU模式下无线程交互开销，专心做垃圾收集，简单高效
  - 适用场景
    - 特别适合限定单 CPU 的环境
    - Client 模式下的默认新生代收集器，用户桌面应用场景分配给虚拟机的内存一般不会很大，所以停顿时间也是在一百多毫秒以内，影响不大
- ParNew收集器
  - 特点
    - Serial收集器的多线程版本
  - 适用场景
    - 许多运行在 Server 模式下的虚拟机中的首选新生代收集器
    - 除了 Serial 收集器外，只有它能和 CMS 收集器搭配使用
- Parallel Scavenge收集器

  - 特点
    - 新生代收集器，使用复制算法，并行多线程
    - 吞吐量优先收集器：CMS 等收集器会关注如何缩短停顿时间，而这个收集器是为了吞吐量而设计的
  - 适用场景
    - 可以高效利用CPU时间，尽快完成程序的运算任务，适合后台运算不需要太多交互的任务
- Serial Old收集器
  - 特点
    - Serial收集器的老年代版
    - 使用单线程，标记-整理算法
  - 适用场景
    - 主要给 Client 模式下的虚拟机使用

- Parallel Scavenge收集器
  - 特点
    - Parallel Scavenge收集器的老年代版本
    - 使用多线程，标记-整理算法
  - 适用场景
    - 主要配合 Parallel Scavenge 使用，提高吞吐量
    - 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑这个组合

- CMS收集器

  - 特点
    - 设计目标：获得最短回收停顿时间
    - 注重服务响应速度
    - 标记-清除算法
  - 适用场景
    - 互联网网站或者B/S系统的服务器
  - 缺点
    - 对 CPU 资源敏感，虽然不会导致用户线程停顿，但是会占用一部分线程（CPU资源）而导致应用程序变慢，吞吐量降低
    - CMS 收集器无法处理`浮动垃圾`。在 CMS 并发清理阶段，用户线程会产生垃圾。如果出现 Concurrent Mode Failure 失败，会启动后备预案
    - 临时启动 Serial Old 收集器重新进行老年代垃圾收集，停顿时间更长了
    - `-XX:CM SInitiatingOccupancyFraction`设置的太高容易导致这个问题
    - 基于标记-清除算法，会产生大量空间碎片

- G1收集器

  - 特点
    - Garbage-First，即优先回收价值最大的 Region
    - 并行与并发：并发标记，并行最终标记与筛选回收
    - 分代收集
    - 空间整合：基于标记-整理算法，不会产生碎片
    - 可预测的停顿：G1收集器将整个 Java 堆换分为多个代销相等的独立区域，避免在整个 Java 堆中进行全区域的垃圾回收，跟踪各个 Region 里面垃圾堆积的价值大小，后台维护一个优先列表，每次根据运行的收集时间，优先回收价值最大的 Region

  - 适用场景

  - 四个阶段

    1. 初始标记
       - 只标记 GC Roots 能直接关联到的对象，速度很快
       - 修改 TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能够在正确可用的 Region 中创建新对象，这阶段需要停顿线程

    2. 并发标记
       - GC RootsTracing 过程
       - 该阶段对象变化记录在线程 Remembered Set Logs 中

    3. 最终标记
       - 修正并发期间因用户程序运作而导致标记产生变动的部分对象的标记记录
       - 把 Remembered Set Logs 数据合并到 Remembered Set 中
       - 这个阶段需要停顿，但是可并行执行

    4. 筛选回收
       - 对各个 Region 回收价值和成本进行排序，根据用户期望 Gc 停顿时间制定回收计划
       - 与 CMS 不一样，不用和用户线程并发执行，提高收集效率，使用标记-整理算法，不产生空间碎片

  