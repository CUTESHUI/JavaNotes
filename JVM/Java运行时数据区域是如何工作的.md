## Java运行时数据区域是如何工作

#### 程序计数器

- 存储：当前线程所执行的字节码的行号指示器
- 执行native方法时为空
- 这个区不会出现OOM异常



#### JAVA虚拟机栈

- 存储：Java方法执行过程中的栈帧（每个方法创建一个栈帧），存储局部变量表，操作数栈，动态链接，方法出口等信息
- 局部变量表：存放了编译期可知的各种基本数据类型、对象引用和 return Address（指向了一条字节码指令的地址）类型
- 虚拟机参数设置：`-Xss`设置虚拟机栈的大小



#### 本地方法栈

- 为本地方法服务，JVM规范没有对这块做太多约定，有的虚拟机直接把本地方法栈和虚拟机栈合二为一



#### Java堆

- 存储：存储对象实例
- 垃圾收集器管理的主要区域
- 虚拟机参数设置
  - `-Xmx` 最大值
  - `-Xms`最小值



#### 方法区

- 存储：存储已加载的类信息，常量，静态变量，即时编译器编译后的代码
- 垃圾收集行为在此区域比较少发生
- 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量(static final)和符号引用
- 方法区包含 class 文件信息，class 文件信息包含：魔数，版本号，常量池，类父类和接口数组，字段，方法等信息
- 一个class文件对应一个常量池，为静态常量池。JDK 运行时，会根据静态常量池生成对应的运行时常量池
- JDK7 之前运行时常量池逻辑包含字符串常量池，此时 hotspot 虚拟机对方法区的实现为**永久带**
- JDK7 字符串常量池从方法区移到了堆中，这里只是把字符串常量池单独拿到了堆中，运行时常量池剩下的东西还在方法区，也就是hotspot的永久带
- JDK8 中 hotspot 移除了永久带，用**元空间**取代，此时字符串常量池还在堆中，运行时常量池还在方法区，只不过方法区的实现从永久带变成了元空间
- JDK8 的元空间不在 JVM 运行时数据区，而在本地内存，此时本地内存包括：元数据区(元空间)和直接内存。



#### 直接内存

- 不属于 JVM 运行时数据区
- jdk1.4+ NIO 可以使用native函数库分配堆外内存
- 虚拟机参数设置：`-XX:MaxDirectMemorySize`
- 当各区内存大于物理内存限制的时候，会抛出OOM异常



#### JVM运行时数据区是如何工作的

- 线程：每个线程都有对应的程序计数器，虚拟机栈，本地方法栈

- 虚拟机栈

  - 假设有如下调用关系：`ClassA.invokeA() -> ClassB.invokeB() -> ClassB.doInvokeB() -> ClassC.execute()`
  - 每个方法调用，都有一个栈帧入栈，调用完成，栈帧从虚拟机栈上出栈
  - 虚拟机栈是一个 LIFO 的栈

- 栈帧

  - 本地变量表

    - 本地变量表长度编译期确定
    - 一个本地变量（Slot）可以存32位以内的数据，可以保存类型为 int, short, reference, byte, char, floath和returnAddress的数据
    - 两个本地变量可以保存类型为 long 和 double 的数据

  - 操作数栈

    - 每个栈帧内部都包含一个称为操作数栈的后进先出栈，提供给方法计算过程使用

  - 动态链接

    - 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用来支持方法调用过程中的动态链接
    - class 文件的常量池中包含了大量的符号引用，字节码中的方法调用指令以常量池中指向的符号引用作为参数，这些符号引用通过两种方式最终转换为直接引用：

    - 静态解析：一部分在类加载阶段或者第一次使用的时候转换为直接引用
    - 动态链接：在运行期间转换为直接引用

  - 返回地址

    - 在方法退出之后，需要返回到方法被调用的位置继续执行
    - 退出时可能需要执行的操作

    - 恢复上层方法局部变量表和操作数栈
    - 如有有返回值，把该值压入调用者栈帧的操作数栈中
    - 调整PC计数器的值以指向方法调用指令的下一条指令地址

- 线程可以访问 Java 堆和方法区



#### HotSpot

- 对象的访问定位
  - 直接使用指针访问
    - 通过栈上的 reference 数据来操作堆上的具体对象
    - reference 指向了堆中的具体对象
  - 通过句柄访问
    - 句柄中包含了对象实例数据与类型数据各自的具体地址信息