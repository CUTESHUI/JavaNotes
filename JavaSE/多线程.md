## 多线程

#### 程序、Program

- 为完成特定的任务，用某种语言编写的一组指令集合

- 一段静态的代码、静态对象



#### 进程、Process

- 是程序的一次执行过程
- 是一个动态的过程：它有自己的创建、存在和消亡过程 — 生命周期
- 作为资源分配的单位
- 系统在运行时会为每个进程分配不同的内存区域



#### 线程、Thread

- 是一个程序内部的一条执行路径
- 若一个进程同一时间并行执行多个线程，就称支持多线程
- 作为调度和执行的单位
- 每个线程拥有独立的运行栈和程序计数器
- 线程的切换开销小
- 一个进程中的多个线程共享相同的内存单元 / 内存地址空间：它们从同一个堆中分配对象，可以访问相同的变量和对象
- 多个线程操作共享的系统资源会带来安全隐患
- 一个 Java 程序至少有三个线程



#### 并行

- 多个 CUP 同时执行多个任务
- 比如：多个人同时做不同的事
- 多个事件在同一时刻完成
  - 9:00 — 9:20 我左手吃面包，同时右手写字，是并行执行



#### 并发

- 一个 CPU 采取时间片的方式同时执行多个任务

- 比如：多个人做同一件事、秒杀 

- 多个事件在同一个时间间隔内发生

  - 9:00 — 9:10 只吃面包

  - 9:20 — 9:20 只写字

  - 9:00 — 9:20 我吃面包和写字，是并发执行



#### 多线程的优点

- 提高应用程序的响应
- 增强用户体验
- 提高计算机系统 cpu 的利用率
- 改善程序结构



#### 何时需要多线程

- 程序需要同时执行两个及多个任务
- 需要一些后台运行的程序时
- 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等



#### 多线程的创建

- 方式一：继承 Thread 类
  1. 创建一个继承于 Thread 类
  2. 重写 Thread 类中的 run( )
  3. 创建 Thread 类的子类对象
  4. 通过此对象调用 .start( ) 方法
  
- 方式二：实现 Runnable 接口
  1. 创建一个实现 Runnable 接口的类
  2. 实现类去实现 Runnable 中的 抽象方法：run( )
  3. 创建实现类的对象
  4. 将此对象作为参数传入 Thread 类的构造器中，创建 Thread 类的对象
  5. 通过 Thread 的对象调用 Runnable 类型的 target ( 实现类的对象 ) 的 start( )
  
- 创建线程的以上方式比较
  - 开发中，优先选择 实现的方式
    - 原因
      1. 没有类的单继承性的局限性
      2. 更适合处理多个线程有共享数据的场景
  - 联系
    - Thread 类也实现了 Runnable
  - 相同点
    - 两种方式都需要重写 run( )
    - 都将要实现的逻辑写在 run( ) 中

- 方式三：实现 Callable 接口

  - 相比 Runnable 接口更强大

    - 相比 run( )，可以有返回值

    - 方法可以抛出异常

    - 支持泛型返回值

    - 需要借助 Future Task 类，比如获取返回值结果

  1. 创建实现Callable 接口的实现类
  2. 实现 call( )，将此线程要实现的逻辑写在 call( )
  3. 创建 Callable 接口实现类的对象
  4. 将此对象作为实参传递到 FutureTask 类的构造器中，创建对象
  5. 将 FutureTask 的对象作为实参传递到 Thread 类的构造器中，创建对象，调用start( ) 

  - 

- 方式四：使用线程池

  - 提前创建好多个线程，放入线程池中，方便直接获取，使用完放回池中

  - 好处

    - 提高响应速度，减少了创建新线程的时间

    - 降低资源消耗，重复利用线程池的线程，不需要每次都创建，实现重复利用，类似于公共交通工具

    - 便于线程的管理

      ExecutorService 是接口，接口没有对象，也就无法调用更丰富的方法，

      那就只能找借口的实现类，实现类有对象：ThreadPoolExecutor

      ExecutorService s = new Executor.newFixedThreadPool;

      ThreadPoolExecutor ss = (ThreadPoolExecutor) s;

      ss.方法，如下：

      1. corePoolSize( )：线程池大小
      2. maximumPoolSize( )：最大线程数
      3. keepAliveTime( )：线程没有任务时最多保持多长时间终止

  - JDK 5.0 起提供了线程池相关 API ：ExecutorService、Executors

    - ExecutorService：真正的线程池接口
    - Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池
      1. Executors.newCachedThreadPool( )：创建一个可根据需要创建新线程的线程池
      2. Executors.newFixedThreadPool( )：创建一个可重用的固定线程数的线程池
      3. Executors.newSingleThreadPool( )：创建一个只有一个线程的线程池
      4. Executors.newScheduleThreadPool( )：创建一个线程池，它可安排在给定延迟后运行命令，或定期执行

- start( )
  - 启动当前线程
  - 调用当前线程的 run( )
  
- 将此线程执行的方法声明在 run( )



#### Thread类的常用方法

- void start( ) ：启动线程，并调用 run 方法
- run( )  
  - 线程在被调度时使用的方法
  - 通常需要重写，将要执行的操作声明在此方法 中
- String getName( ) ：返回线程的名字
- void setName( String name ) ：设置线程的名字
- static Thread currentThread ：返回当前的线程
- static void yield( ) ：线程让步
  - 暂停当前正在执行的线程，把执行机会让给优先级相同或者更高的线程
  - 若队列中没有同优先级的线程，忽略此方法
- join( ) ：当某个程序的执行流中调用其他线程的 join 时，调用线程将被阻塞，直到 join 方法加入的 join 线程执行完
- static void sleep( ) 
  - 抛出 InteruptedExecption 异常
  - 令当前活动线程在制定时间段内放弃对 CPU 的控制，使其他线程有机会被执行，时间到后重新排队




#### 线程的调度

- 调度策略
  - 时间片
  - 抢占式：高优先级的线程抢占 CPU 

- Java 的调度方式
  - 同优先级的线程组成先进先出队列 (先来先服务 )， 使用时间片策略
  - 对于高优先级的线程，使用优先调度的抢占式策略
- 线程的优先等级
  - MAX_PRIORITY = 10
  - MIN_PRIORITY  = 1
  - NORM_PRIORITY  =  5
- 方法
  - getPriority( ) ：返回线程的优先级值
  - setPriority( int newPriority ) ：改变线程的优先级值
- 说明
  - 线程创建时继承父线程的优先级
  - 低优先级的线程只是获得调度的概率低，并非一定在高优先级之后才被调用



#### 线程的生命周期

- JDK 中用 Thread.State 类定义了线程的几种状态

- 一个完整的线程的生命周期要经历以下五个状态

  - 新建
    - 当一个 Thread 类或者其他子类的对象被声明并创建时，新生的线程诞生

  - 就绪
    - 新生的线程被 start( ) 后，将进入线程队列等待 CPU 时间片，此时已经具备了运行条件，只是没有分配到 CPU 资源

  - 运行
    - 当就绪的线程被调度并分配到 CPU 资源时，便进入运行状态，其中 run( ) 定义了线程的操作和功能

  - 阻塞
    - 在某种特殊情况下，被人为挂起或者执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态

  - 死亡
    - 线程完成了全部工作或者线程被提前强制性中止或出现异常导致结束



#### 线程的同步

- 举例

  - 问题：卖票过程中，出现重票、错票  —>  线程安全问题
  - 问题原因：当某个线程在操作车票时，尚未操作完成，其他线程参与进来也操作

- 在 Java 中，通过同步机制，解决线程安全问题

  - 方式一：同步代码块

    synchronized( 同步监视器 ) {

    ​		// 需要同步的代码

    }

    - 说明
      1. 需要同步的代码：操作共享数据的代码
      2. 共享数据：多个线程共同操作的变量
      3. 同步监视器：俗称 锁。任何一个类的对象都可以充当锁
    - 多个线程必须要共用同一把锁

  - 方式二：同步方法
    - 如果操作共享数据的代码完整声明在一个方法内，不妨将此方法声明为同步
    - 非静态的同步方法，同步监视器： this
    - 静态的同步方法，同步监视器：当前类本身

- 同步的好处

  - 解决了线程安全问题

- 同步的坏处

  - 操作同步代码时，只能有一个代码参与，其他线程等待
  - 相当于一个单线程的过程，效率低



#### Lock

- 从 JDK5.0 后 Java 提供了更强大的线程同步机制：通过显式定义同步锁对象( Lock对象 )来实现同步
- Lock 接口，是控制多个线程对共享资源进行访问的工具
- ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，可以显示加锁、释放锁
- 使用步骤
  1. 实例化 ReentrantLock 对象
  2. 调用锁定方法 lock( )
  3. 调用解锁方法 unlock( )
- synchronized 与 lock 异同
  - 相同
    - 都可以解决线程安全问题
  - 不同
    - synchronized 在执行完相应的同步代码后，自动释放同步监视器
    - lock 需要手动的启动同步( lock( ) )， 结束同步也需要手动( unlock( ) )
  - 优先使用顺序：lock — 同步代码块 — 同步方法



#### 死锁

- 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，形成死锁

- 出现死锁后，不会抛出异常，不会出现提示，只是所有的线程都处于阻塞状态，无法执行下去



#### 线程通信

- 涉及到的三个方法
  - wait( ) ：当前线程进入阻塞状态，并释放同步监视器
  - notify( ) ：唤醒被阻塞的一个线程，如果存在多个线程，唤醒优先级高的
  - notifyAll( ) ：唤醒被阻塞的所有线程
- 说明
  1. wait( )、notify( )、notifyAll( ) 必须使用在同步代码块和同步方法中
  2. wait( )、notify( )、notifyAll( ) 的调用者必须是同步代码块和同步方法的同步监视器
  3. wait( )、notify( )、notifyAll( ) 定义在 Object类，由此保证
- 生成者 消费者问题
- sleep( ) 与 wait( ) 的异同
  - 相同
    - 一旦执行方法，都可以使得当前线程进入阻塞状态
  - 不同
    - 声明的位置不同
      1. Thread 类中声明 sleep ( )
      2. Object 类中声明 wait ( )
    - 调用的范围不同
      1. sleep ( ) 可以在任何场景下调用
      2. wait ( ) 必须使用在同步代码块和同步方法中
    - 关于是否释放同步监视器：如果两个方法都使用在同步代码块和同步方法中
      1. sleep ( ) 不会释放同步监视器 / 锁
      2. wait ( ) 会释放同步监视器 / 锁

