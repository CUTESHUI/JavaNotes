## 泛型

- 设计背景

  - 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决
  - 因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。
  - Collection<E>，List<E>，ArrayList<E> 这个<E>就是类型参数，即泛型

- 概念

  - 标签

  - 所谓泛型，就是允许在定义类、接口时通过一个**标识**，表示类中某个属性的类型或者是某个方法的返回值及参数类型

  - 这个类型参数将在使用时才确定

    例如，继承或实现这个接口，用这个类型声明变量、创建对象时才确定

- 参数化类型 / 类型参数

  - 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许在创建集合时再指定集合元素的类型

  - 例如：List<String>，这表明该 List 只能保存字符串类型的对象

- 为什么要有泛型呢，直接 Object 不是也可以存储数据吗

  - Object 向下强转会有强制转换问题

  - 安全性：把类型明确工作推迟到创建对象或调用方法时
  - 简洁性：不用再强制转换 / 不用总在 instanceof
  - 健壮性：Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常
  - 可读性：在编写集合时，就限定了类型

- 自定义泛型

  - 泛型的声明

    - interface List<T> 和 class GenTest<K, V> 
    - 其中，T、K、V 不代表值，而是表示类型。这里使用任意字母都可以。常用 T 表示，是 Type 的缩写

  - 泛型的实例化

    - 指定完泛型类型后，在集合类或接口中，内部结构 ( 属性、方法、构造器... ) 都是使用制定好的泛型类型

    - 泛型的类型必须是类，也就不能用基本数据类型，只能使用包装类
    - 实例化时没有指定泛型的类型，默认为 java.lang.Object 类型
    -  把一个集合中的内容限制为一个特定的数据类型，这就是generics / 泛型背后的核心思想

- 泛型类、泛型接口

  - 泛型类可能有多个参数，比如：<E1, E2, E3>

  - 泛型类的构造器如下：public GenericClass( ){ }，构造器不加 <>

  - 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致

  - 泛型不同的引用 / <>里不一样，不能相互赋值

    - 尽管在编译时 ArrayList<String>和 ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到 JVM中

  - 泛型如果不指定，对应的类型均按照Object处理，但不等价于Object

  - 泛型要使用一路都用。要不用，一路都不要用

  - 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象

  -  jdk1.7，泛型的简化操作：ArrayList<Fruit> fruitList = new ArrayList<>();

  - 泛型的指定中不能使用基本数据类型，用包装类替换

  - 在类 / 接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型

  - 静态方法中不能使用类的泛型，静态早于对象的创建，而泛型是在实例化 / 造对象时使用

  - 父类有泛型，子类可以选择保留泛型，也可以选择 指定泛型类型

  - 子类保留父类的泛型：泛型子类

    - 全部保留
    - 部分保留

    结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型

- 泛型方法

  - 方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类
  - 可以声明为静态的
  - 在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型
  - 泛型方法的格式
    - [访问权限] <泛型> 返回类型 方法名([泛型标识 参数名称]) 抛出的异常

- 通配符

  - 使用类型通配符：？
    - 比如：List<?> ，Map<?,?>
    - List<?> 是 List<String>、List<Object>等各种泛型 List 的父类
  - 想读取 List<?> 的对象 list 的元素时，可以。因为不管list的真实类型是什么，它包含的都是Object
  - 想向 List<?> 的对象 list 添加元素时，不行。因为我们不知道添加的元素类型，我们不能向其中添加对象
  - 有限制的通配符
    - 通配符指定上限 extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即 <= 
    - 通配符指定下限 super：使用时指定的类型不能小于操作的类，即 >=