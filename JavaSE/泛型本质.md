## 泛型

#### Java 为什么需要泛型

- 泛型最众所周知的应用就是容器类
- 一般我们只会用容器来存储一种类型的队形，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，由编译器来保证类型的正确性
- Java 在泛型出现之前，只能通过 Object 来实现类型泛化，手动转换导致只有程序员和运行期间的 JVM 才知道这个 Object 是什么类型的对象，编译期间也无法检查 Object 强转是否成功的，这样不可避免的在运行期抛出更多的 ClassCaseException



#### 泛型本质

- 在引入了泛型之后，为了能够让虚拟机解析、反射等各种场景正确获取到参数类型，JCP 组织修改了虚拟机规范，引入了 Signature、LocalVariableTypeTable新属性
- 假设，编写一个泛型类，编译之后，使用`javap -v`命令查看泛型类的反汇编信息，在实例构造器中的 code 中，发现有 LocalVariableTypeTable
- LocalVariableTypeTable
  - 这个是方法的实例构造器的一个可选属性，如果方法中使用到了泛型，则会出现这个属性
- Signature
  - LocalVariableTypeTable 里面携带了一个具有类型的 Signature 签名
  - Signature 是Java编译的时候生成的，用于标识对应的类、变量或者属性等的类型的签名
  - Signature 中除了原生类型，也保存了参数化类型（即泛型）的信息
  - 在Java中，不管使用到了具体的类型或者是泛型，都需要给定一个类型签名（Signature）
  - 以下场景都会给定类型签名：
    - 具有通用或者具有参数化类型的超类或者超接口的类
    - 方法中的通用或者参数化类型的返回值或者入参，以及方法的 throw 子句中的类型变量
    - 任何类型、类型变量、或者参数化类型的字段、形式参数或者局部变量
  - 在使用到了泛型的代码中，因为编译时并不知道最终执行的具体类型，所以会生成这个 Signature 用来表示泛型
  - Signature 目前仅在  Class 的反射和编译阶段会用到
- 类型擦除
  - 反编译泛型类的 get / set，方法中的泛型替换为了 Object，也就是发生了 类型擦除，因此在实际运行时，都是 Object 类型



#### 缺点

- Java泛型中，在泛型类型上执行操作时，会产生问题
- 擦除要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法
- 这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使他们继承自特定的类，或者特定的接口
- 在某些情况下，你最终可能会使用普通类或者普通接口，因为限定边界的泛型和可能会和指定类或接口没有任何区别
- 某些编程语言提供的一种解决方法：潜在潜在机制 或 结构化类型机制（鸭子类型机制：如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当做鸭子对待）
- 潜在类型机制
  - 使得你可以横跨类继承结构，调用不属于某个公共接口的方法
  - 一段代码可以声明：“我不关心你是什么类型，只要你可以 speak( ) 和 sit( ) 即可” 由于不要求具体类型，这样的代码就能更加泛化



#### Java 对缺乏类型机制的补偿

- 对于潜在类型机制的一种补偿，可以使用**反射**



