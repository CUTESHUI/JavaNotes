## 面向对象

#### 学习面向对象的三条主线

- JAVA类及类的成员
  - 属性
  - 方法
  - 构造器
  - 代码块
  - 内部类
- 面向对象的三大特征
  - 封装
  - 继承
  - 多态
- 其他关键字
  - this
  - super
  - static
  - final
  - abstract
  - interface
  - package
  - import



#### 什么是面向对象？

Object Oriented Programming

OOP

将功能封装进对象，强调具备了功能的对象，以类 / 对象 为最小单位，考虑**谁来做**。



#### 万事万物皆对象

1. 在 Java 语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构
   - Scanner、String 等
   - 文件 File
   - 网络资源 URL

2. 涉及到 Java语言与前端 html 、后端数据库交互时，前后端的结构在 Java 层面交互时，都体现为类、对象



#### 类 和 对象

- **类 ( class )** 和  **对象 ( object )** 是 面向对象的核心概念
- 类    ： 对一类事物的描述，是**抽象**的，是概念上的定义
- 对象 ：是**实际存在**的该类事物的每个个体， 因而也称为**实例 ( instanse )** 

- 面向对象程序设计的重点是 类的设计
- 设计类 就是， 设计类的成员



#### 类的成员

- #### 属性

  - 对应类中的 **成员变量**

  -  = filed

  - 属性 VS 局部变量

    - 相同点：

      1. 定义变量的格式： 数据类型 变量名 = 变量值；

      2. 先声明，后使用
      3. 都有对应的作用域

    - 不同点：

      1. 在类中声明的位置不同
         - 属性，直接定义在{ }内
         - 局部变量，声明在方法内、方法行行参、代码块内、构造器内部、构造器形参的变量
      2. 关于权限修饰符的不同
         - 属性：可以在声明属性时，指明其权限，使用权限修饰符
         - 常用的权限修饰符：private、public、protected、 缺省
         -   局部变量：不可以使用权限修饰符
      3. 默认初始化值不同
         -  属性：根据其类型都有默认初始化值
           - byte、short、int、long， 0
           - float、double， 0.0
           - boolean，false
           - char： 0
           - 引用数据类型 ( 类、数组、接口、String )：null
         - 局部变量：没有默认初始化值。所以，在调用局部变量前一定要显式赋值
      4. 内存中加载的位置
         - 属性： 堆
         - 局部变量： 栈

- #### 方法

  - 对应类中的 **成员方法** 

  - = 函数 = method

  - 方法声明： 权限修饰符  返回值类型  方法名 ( 形参 列表 ) { 方法体 }

    1. 权限修饰符

       - private、public、protected、 缺省

    2. 返回值类型

       - 有返回值
         - 在方法声明时，必须指定返回值类型
         - 在方法体中用 return 关键字来指定类型的数据

       - 无返回值
         - 在方法声明时，使用 void
         - 通常，不需要使用 return

    3. 方法名

    4. 形参

    5. 方法体

  - 方法可以调用当前类的 属性 / 方法

  - 方法中不可以再定义方法

  - 方法的**重载**

    1. 概念

       - 在同一个类中，允许存在一个以上重名的方法，只要它们的参数个数或参数类型不同
       - OverLoad
  2. 特点
    
     - 与返回值类型无关
       - 只看形参列表，且形参列表不同
       - 调用时，根据方法参数列表的不同来区分
    3. 两同一不同

       - 同：同一个类，相同方法名

       - 不同：参数列表不同
  4. 与方法的权限修饰符、返回值类型、形参变量名、方法体都无关
    5. 自动提升，参数的数据类型
  6. 对于重载而言，在方法调用前，就确定了所要调用的方法，称为 “早绑定“ / “静态绑定”
  
  - 方法的**重写**

    1. 定义

       - override、overwrite
- 在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖
       - 重写方法后，子类的方法会覆盖父类的
       - 重写后，子类的对象调用重写后的，父类的对象调用重写前的 原本的
       - 非static的方法才能重写

    2. 要求

       - 子类重写方法必须和父类被重写的方法，具有相同的方法名称、形参列表
       - 子类重写方法返回值类型 <= 父类被重写方法的返回值类型
       - 子类重写方法的访问权限 > 父类被重写方法的访问权限
       - 子类不能重写父类中 private 方法
       - 子类重写方法抛出的异常不能大于父类重写方法抛出的异常

    3. 注意

       - 同一个包的不同子类，不能调用父类中声明为private和缺省的属性、方法

       - 在不同包的子类中，不能调用父类包中声明为private和缺省的属性、方法

    4. 对于重写而言，只有等到方法运行时，才确定所要调用的方法，称为 “晚绑定” / “动态绑定” 

  - 可变个数的形参

    - 格式：数据类型 ... 变量名
    - 调用时，传入的参数个数可是多个
    - 可变参数的方法与本类中方法名相同，形参类型相同的数组不构成重载

  - 方法参数的值传递机制

    1. 方法含有参数
       - 形参：方法 声明 时的参数
       - 实参：方法 调用 时实际传给形参的参数
    2. 如果参数是基本数据类型，此时实参赋给形参的是真实的实参存储的 数据值
    3. 如果参数是引用数据类型，此时实参赋给形参的是真实的实参存储的 地址值

- #### 构造器

  - 构造方法、constructor
  - 作用：
    - 创建对象
    - 给对象初始化
  - 说明
    - 如果没有显示定义类的构造器的话，则系统默认提供一个人空参的构造器
    - 定义构造器的格式：权限修饰符 类名 ( 形参列表 ) { }
    - 一个类中多个构造器，彼此构成重载
    - 一旦我们显示定义了构造器，系统就不再提供默认的空参构造器
    - 一个类中至少有一个构造器
  - 特征
    - 与类同名
    - 不能声明返回值
    - 不能被 static、final、synchronized、abstract、native 修饰
    - 不能用 return 语句返回值

- #### 代码块

  - 作用：初始化类、对象
  - 代码块如果有修饰的话，只能用 static
  - 分类：静态代码块，非静态代码块
  - 代码块 先于 构造器执行
  - 静态代码块 先于 非静态代码块执行
  - 有继承 的执行顺序：由父及子，静态先行
  - 静态代码块
    - 内部可以有输出语句
    - 随着类的加载而执行，且 只执行一次
    - 可定义多个静态代码块，并按先后顺序执行
    - 只能调用静态的属性、方法
    - 作用：初始化类的信息
  - 非静态代码块
    - 内部可以有输出语句
    - 随着对象的创建而执行
    - 每创建一个对象，就执行一次非静态代码块
    - 可以调用静态和非静态的属性、方法
    - 作用：可以在创建对象时，对对象的属性进行初始化

- #### 内部类

  - Java中允许将一个类A声明在另一个类B中，则类A称为内部类

  - 分为：成员内部类( 静态、非静态 )、局部内部类( 方法内、代码块内、构造器内 )

  - 成员内部类

    1. 作为外部类
       - 可以调用外部类的属性、方法
       - 可以被四种不同权限修饰

    2. 作为类
       - 类内可以定义属性、方法、构造器
       - 可以被 final 修饰，表示此类不可以被继承
       - 可以被 abstract 修饰，表示此类不可以实例化

  - 局部内部类

  - 抽象类与内部类

    1. 相同
    2. 不同



- 调用对象的 属性、方法

  - 调用属性： 对象.属性
  - 调用方法： 对象.方法

- 创建类的对象

  - = 类的实例化 = 实例化类

- 落地实现

  - 设计类，设计类的成员
  - 创建类的对象
  - 调用类的结构

- 如果创建类的多个对象  则没个对象都独立拥有一套类的属性 ( 非static )。所以，我们羞给一个对象属性，不影响另外一个对象的属性

  

- 堆 存放 对象实例

- 栈 存放 局部变量

- 方法区 存放 类信息、常量、静态变量、即时编译器编译后的代码

 

- return 关键字的使用
  - 使用范围： 方法体
  - 作用：
    - 结束方法
    -  针对有返回值的方法
  - return 后不可以有执行语句




#### 封装性

- 我们设计程序追求 “ 高内聚 ”  “ 低耦合 ”
  - 高内聚：类的内部数据操作细节自己完成，不允许外部干涉
  - 低耦合：仅对外部暴露少量的方法用于使用 

- 封装的特点
  - 隐藏对象内部的复杂性，只对外公开简单的接口
  - 便于外界调用，提高系统的可用性、可维护性
  - 把该隐藏的隐藏起来，该暴露的暴露出来
- 封装性的体现

1. 我们将类的属性 ( xxx ) 私有化 ( private ) ，同时，提供公共的方法 ( public ) 来获取 ( get ) 和设置 ( set ) 此属性
2. 不对外暴露私有的方法
3. 单例模式

- 封装性的体现需要权限修饰符

1. Java 规定4中权限修饰符 ( 从小到大 ) ：private、缺省、protected、public

| 权限修饰符 | 类内部 | 同一个包 | 同一个子类 | 同一个工程 |
| :--------: | :----: | :------: | :--------: | :--------: |
|  private   |   √    |          |            |            |
|    缺省    |   √    |    √     |            |            |
| protected  |   √    |    √     |     √      |            |
|   public   |   √    |    √     |     √      |     √      |

2. 对于class，只可用 public 和 缺省

3. 4 种权限修饰符可以用来修饰 类 和 类的内部结构：属性、方法、构造器、内部类
4. 修饰类，只能使用：缺省、public

- 总结： Java 规定的4种权限修饰符来修饰类及类的内部结构，体现 类 和 类内部结构在被调用时可见性的大小



#### 继承性

- extend：拓展、延伸

- 继承性的好处

  - 减少代码的冗余
  - 方便功能拓展

- 继承性的格式：class A extends class B { }

  - A：子类、派生类、subclass

  - B：父类、超类、基类、superclass

- 体现：一旦子类继承父类后，子类就获得了父类中声明的所有属性、方法
- 特别：父类中声明为private的属性、方法，子类继承父类后，仍然认为获取了父类中的私有化属性、方法。只是因为封装性的影响，使得子类没办法直接调用父类的结构：可以get来获取属性
- 子类继承父类后，还可以声明自己的属性和方法，实现功能拓展
- 子类和父类的关系，不同于集合和子集的关系
- 关于继承的规定：
  - 一个父类可以被多个子类继承
  - 一个子类只能有一个父类：单继承性
  - 子类直接继承的父类，称为：直接父类
  - 子类间接继承的父类，称为：间接父类
  - 子类继承父类后，就获得了直接父类和间接父类中所有的属性和方法
- 如果我们没有显示的声明一个父类，则此类继承于 java.lang.Object 类
- 面试：谈谈对继承性的理解
  - 让类与类之间产生继承关系， 达到代码的重用
  - 不用白手起家



#### 多态性

- 可以理解为一个事物的多种形态
- 运行时行为
- 何为多态性
  - 对象的多态性：父类的引用指向子类的对象
  - 方法：编译看左边，运行看右边
    - 编译也就是看父类可以调用的属性和方法，运行是执行右边子类的方法
- 多态的使用：当调用子父类中同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用
- 使用前提
  - 类的继承关系
  - 方法的重写
- 只适用于方法，不适用于属性
- 有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法，但由于变量声明为父类类型，导致编译时只能调用父类的属性和方法，所以无法调用子类中特有的属性和方法

- 如何调用子类中特有的属性、方法
  - 向下转型：使用强制类型转换符
  - 向下转型，必须 new 子类
  - 使用强转时可能出现 ClassCastException
  - instanceof
    - a instanceof A：判断 a 是否为 A 的实例( 对象 )，是 返回true
    - 子类 instanceof 父类：true
  - 父类 = new 子类，if (子类 instanceof 父类 ) { 子类 = ( 子类 )父类，父类. 子类属性、方法 }
- 面试：谈谈对多态性的理解：
  - 实现代码的通用性



#### JavaBean

- 是一种可重用的组件
- 所谓 JavaBean，是符合如下标准的 Java 类：
  - 类是公共的
  - 有一个无参的构造器
  - 有属性，且有对应的 get、set方法
- 用户可以使用 JavaBean 将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包。并且其他开发者可通过内部的 JSP 页面、Servlet、其他 JavaBean、applet程序或者应用来使用这些对象。
- 用户可以认为 JavaBean 提供了一种随时随地的复制和粘贴功能，而不用关心任何改变



#### this

- 理解为：当前对象的


- 在方法内部使用
- 在构造器中使用，表示该构造器 正在初始化的对象
- 可以调用类的属性、方法和构造器
- 什么时候使用：
  - 在方法内需要调用该方法的对象时
  - 可以用 this 来区分形参和属性
  - 形参名和属性名 重名
- this 调用构造器
  - 在类的构造器中，可以显式使用 “ this( 形参列表 ) ”，调用本类中指定的其他构造器
  - 想调用有形参的构造器，本构造器的形参列表中也要有对应的参数作为其中之一
  - 就近原则
  - 构造器中不能调用自己
  - 如果一个类中有 n 个构造器。最多有 n-1 个构造器使用this调用其他构造器，且构造器间不可成环。剩下的那个是super( )
  - 必须声明在当前构造器的首行



#### Super

- 理解为：父类的
- 可以用来调用属性、方法、构造器
- super的使用：
  - 可以在子类的方法或构造器中，通过使用 “ super.属性 / 方法 “ 的方式，显示调用父类中声明的属性、方法
  - 当子类和父类中声明了同名的属性 / 方法时，要想在子类中调用父类中声明的属性 / 方法，则必须显示的使用super来表明是调用父类的，做到区分
  - 可以在子类的构造器中显式的使用 " super( 形参列表 ) " 的方式，调用父类中指定的构造器
  - 必须声明在当前构造器的首行
  - 在类的构造器中，针对 “ this( 形参列表 )" 和 “ super( 形参列表 ) ”。只能二选一
  - 默认调用父类中空参的构造器 
  - 给属性赋值的直接调用 空参super
  - 需要区分形参和属性的时候调用 有形参的super



#### Static

- 理解为：静态的
- 可以用来修饰属性、方法、代码块、内部类
  - 修饰属性
    - 属性，按是否用static修饰又分为：静态属性、非静态属性 ( 实例变量 )
    - 非静态属性：创建了类的多个对象，每个对象独立拥有一套类中的非静态属性，当修改其中一个对象中的非静态属性时，不会导致其他对象中相同非静态属性的修改
    - 静态属性：创建了类的多个对象，多个对象共享同一个静态变量，当通过某一个对象修改静态属性时，会导致其他对象调用此静态属性时，是修改后的
    - 随着类的加载而加载，可以通过 " 类.静态属性 "调用
    - 静态属性加载要早于对象的创建
    - 只要权限可以，可以通过 " 对象.静态属性 "调用
    - 静态 ->  类的加载 -> 对象的创建 -> 对象的消亡 -> 类的消亡 
    - 由于类只会加载一次，静态属性在在内存中也只会存在一份
  - 修饰方法
    - 随着类的加载而加载，可以通过 " 类.静态方法 "调用
    - 静态方法中，只能调用静态方法、静态属性
    - 非静态方法中，静态、非静态的方法和属性都可以调用
    - 不能使用 this、super关键字
- 在开发中，如何确定一个属性、方法是否需要声明为static
  - 属性
    - 被多个对象所共享的
    - 不会随着对象的不同而不同
  - 方法
    - 需要操作静态属性
    - 工具类中
- 直接用类调，而不用再去 new 一个对象去调，是一种优化



#### final

- 理解为：最终的
- 可以用来修饰类、方法、变量
  - 修饰类
    - 不能被其他类继承：String类、System类...
  - 修饰方法
    - 不能被重写
  - 修饰变量
    - 此时的变量 就成 常量
    - 修饰属性
      - 可以考虑赋值的位置有：显示初始化、代码块、构造器
    - 修饰局部变量
      - 修饰形参时，表面此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参，一旦赋值后就只能在方法体内使用，无法重新赋值
      - 不可以改变 final变量本身
- static final 修饰属性：全局常量



#### Package

- 为了更好实现项目中类的管理，提供包的概念
-  使用 Package 声明类或接口所属包，声明在源文件的首行
- 包，属于标识符，遵循标识符的命名规范
- 每 “ .  ”一次就是一层文件目录



#### Import

- 导入指定包的类、接口
- 使用 “ .* “ 导入包下的所有类
- 如果在源文件中使用不同包的同名类，必须使用 “ 全类名. “ 



#### Object

-  是所有Java类的根父类
- Object类的属性、方法具有通用性
- 只声明了空参构造器
- equals( )、 toString( )、hashCode( )、getClass( )、clone( )
- == 与 equals( ) 的区别
  - == ：运算符
    - 可以用在基本数据类型和引用数据类型之间
    - 如果比较的是基本数据类型变量，比较的是两个变量保存时数据是否相等，不一定类型要相同
    - 如果比较的是引用数据类型变量，比较的是两个变量的地址值是否相等
  - equals( ) ：方法
    - 只能适用于引用数据类型
    - Object类中 equals( ) 的定义：
      - return this == object ; 
      - 作用与 == 相同
    - 像 String、Data、File、包装类 等都 override 了Object类中 equals( )，重写后比较的是两个对象的实体内容是否相同
    - 通常情况下，重写 equals( ) 方法，会比较类中的属性是否相等
    - 对称性、自反性、传递性、一致性
- toString
  - 当输出一个对象的引用时，实际上就是调用当前对象的 toString( )
  - 像 String、Data、File、包装类 等都 override 了Object类中 toString( )，返回实体内容信息



#### 包装类

| 基本数据类型 |    包装类     |
| :----------: | :-----------: |
|     byte     |     Byte      |
|    short     |     Short     |
|     int      |  **Integer**  |
|     long     |     Long      |
|    float     |     Float     |
|    double    |    Double     |
|   boolean    |    Boolean    |
|     char     | **Character** |

- Java 提供了8种基本数据类型的包装类，使得基本数据类型的变量也具有类的特征
- JDK 5.0 新特性：自动装箱、自动拆箱
  - 自动装箱：
    - int n = 10，Integer n1 = n....
  - 自动拆箱
    - Integer n1 = new Integer(10)，int n = n1...
- 基本数据类型 - 包装类 - String类 之间的相互转换
  - 基本数据类型 -> 包装类
    - 调用包装类的构造器
      - 比如：int n，Integer n1 = new Integer(n)...
  - 包装类 -> 基本数据类型
    - 调用包装类的 .value( )
      - 比如：Integer n1 = new Integer(10)，int n = n1.intValue( ) ...
  - 基本数据类型、包装类 -> String类
    - 基本数据类型 + “ ”
      - 比如：int n，String = n + “ ” 
    - 调用String重载的 valueof( )
      - 比如：float f = 12.3，String s = String.valueof( f)...
  - String类 -> 基本数据类型、包装类
    - 调用包装类的 parse( String s )
      - 比如：String s = "123"，int n = Integer.parse(s)



#### 抽象类

- 有时将一个父类设计得非常抽象，以至于没有具体的实例，这样的类叫做抽象类

- abstract关键字的使用

  - 理解为：抽象的
- 可以用来修饰：类、方法
  - 修饰类：抽象类
    - 不能实例化
    - 一定有构造器，便于子类实例化时调用
    - 开发中，都会提供抽象类的子类，让子类实例化，完成相关的操作
  - 修饰方法：抽象方法
    - 只有方法的声明，没有方法体
    - 包含抽象方法的类一定是抽象类，反之，抽象类中可以没有抽象方法
    - 当子类重写了父类中所有的抽象方法，则子类可以实例化
    - 当子类没有重写父类中所有的抽象方法，则子类是一个抽象类，需要 abstract 修饰
  - 注意点
    - 不能修饰属性、构造器、private方法、static方法、final方法



#### 接口 Interface

- 接口就是规范，定义一组规则

- 主要用途就是被实现类实现

- 面向接口编程

- Java中，接口和类是并列的

- 定义接口的成员

  - JDK 7及以前：只能定义 全局常量 和 抽象方法

    - 全局常量：public static final

    - 抽象方法：public abstract

  - JDK 8： 可以定义 全局常量、抽象方法、静态方法、默认方法

- 接口中不能定义构造器，意味着接口不能实例化

- Java开发中，接口通过让类去实现 ( implements ) 的方式去使用

  - 当实现类实现( 重写 )接口中所有的抽象方法，则此实现类就可以实例化
  - 当实现类没有实现( 重写 )接口中所有的抽象方法，则此实现类仍为一个抽象类

- Java可以实现多个接口，弥补了单继承性的局限

  - 格式：class A entends B implemrnts C，D，E...

- 接口与接口之间可以多继承

- 接口的应用：代理模式、工厂模式

  - 代理模式
  - 工厂模式

- JDK 8

  - 接口中定义的静态方法，只能通过接口去直接调用
  - 通过实现类的对象，可以调用默认方法，重写后的
  - 如果子类或实现类继承的父类和实现的接口声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用父类的同名同参数方法 -> 类优先原则
  - 如果实现类实现了多个接口，而这多个接口中定义了同名同参数的方法，那么在实现类没有重写此方法的情况下，报错：接口冲突

- 抽象和接口的异同

  - 相同

    - 不能实例化
    - 都可以包含抽象方法

  - 不同

    - 抽象类 抽象方法的知识点
    - 接口 7 8 9 的知识点

    - 类：单继承性	接口：多继承
    - 类与接口的关系：多实现



#### MVC 设计模式

- 常用的设计模式之一
- 将程序分为三层：视图模型层、控制器层、数据模型层

1. 视图模型层：M、model。显示数据
   - 相关工具类
   - 自定义类
2. 数据模型层：V、view。处理数据
   - 数据库
   - 数据库操作类
   - 数据对象封装类
3. 控制器层：C、control。业务逻辑
   - 应用界面相关
   - 服务相关的
   - 显示适配器
   - 抽取的基类
   - 存放框架

- 描述了程序各个对象间的通信方式，降低了程序的耦合性



#### 单例设计模式

- 要解决的问题
  - 采取一定方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

- 特点
  - 构造器的访问权限设为 private，这样就无法在类的外部产生类的对象
  - 只能调用该类的某个静态方法来返回类内部创建的对象
  - 减少性能开销

- 应用场景
  - 网站的计数器
  - 应用程序的日志应用
  - 数据库的连接池
  - 读取配置文件的类
  - Application

手写步骤

- 饿汉式
  1. 私有化类的构造器
  2. 内部创建类的对象，要求此对象也是静态的
  3. 供公共的静态的方法，返回内部类的对象

- 懒汉式
  1. 私有化类的构造器
  2. 声明当前类的对象，没有初始化

- 区分饿汉式、懒汉式

  - 饿汉式

    - 好处：线程安全

    - 坏处：对象的加载时间过长
- 懒汉式
  
  - 好处：延迟对象的创建
  



#### 模版设计模式

- 要解的问题
  - 当功能内部一部分实现是确定的，一部分实现是不确定的，这时可以把不确定的部分暴露出去，让子类去实现
  - 换句话说，在实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变的部分可以抽象出来，供不同的子类实现