## 异常

- 在程序执行中发生的不正常情况称为 异常
- 语法错误和逻辑错误不是异常
- 分为两类
  - Error：Java虚拟机无法解决的严重问题。一般不编写针对性的代码处理
  - Exception：其他因编程错误或偶然的外在因素导致的一致性问题。可以编写针对性的代码处理
- 捕获错误最理想是在编译期间
- 有的错误只在运行时才发生，比如 数组下标越界、除数为0...
- Java.lang.Throwable ：顶级异常
  - Error
  - Exception
    - 编译时异常 ( checked )
    - 运行时异常 ( unchecked，RuntimeException )
- 异常处理机制一： try—catch—finally
- 异常处理机制二： throws + 异常类型

- 抓抛模型

  - 过程一：“抛”
    - 程序在正常的执行过程中，一旦出现异常，就会在异常代码处生成一个应对异常类的对象，并将此对象抛出
    - 一旦抛出对象以后，其后的代码就不再执行
    - 产生异常对象

  - 过程二：“抓”
    - 可以理解为异常的处理方式，有机制一、二

- try—catch—finaly

  - 框架：

    try{ 

    ​			可能出现异常的代码

    } catch ( 异常类型1 变量名 ) {

    ​			处理异常的方式1

    } catch ( 异常类型2 变量名 ) {

    ​			处理异常的方式2

    }...

    finaly {

    ​			一定会执行的代码

    }

  - 说明

    - 使用 try 将可能异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应的异常对象，根据此对象的异常类型，去 catch 中匹配，一旦匹配成功就进入 catch 并处理。一旦处理成功，就跳出当前的 try—catch 结构，继续执行其后的代码
    - catch 类中的异常类型，如果没有子夫类关系，谁声明在上无所谓
    - catch 类中的异常类型，如果有子夫类关系，要求子类一定要声明在父类上
    - 常用的异常对象处理方式
      1. String	getMessage( ) ： 获取异常的描述信息
      2. printStackTrace( )  ： 打印堆栈里的信息
    - 在 try 结构中定义的变量，出了 try 结构就无法再调用
    - finaly 是可选的
    - finaly 中声明的是一定会被执行的代码，即使 catch 中又出现了异常，try 中有 return 语句，也一定会执行，在return前
    - 像数据库连接、输入输出流、网络编程socket等资源，JVM 无法自动回收，我们需要自己手动的进行资源的释放，这就需要声明在 finaly 中
    - 开发中，由于运行时异常比较常见，就不编写 try—catch—finaly 来处理，针对编译时异常，一定要处理异常

- throws + 异常类型

  - 一层一层向上甩锅
  - 写在方法的声明处，指明此方法执行时可能会抛出的异常类型，一旦出现异常，仍会在异常代码处生成一个异常对象，此对象满足异常类型时，就会被抛出
  - 一旦出现异常，异常之后的代码就不会执行了

-  try—catch—finaly： 真正将异常处理了

-  throws + 异常类型： 只是将异常抛给了方法调用者，并没有将异常真正处理了

- 开发中，如何选择用啥处理机制
  - 如果父类中被重写的方法没有 throws 方式处理异常，则子类重写的方法也不能用 thows，如果有异常 子类中只能用 try—catch—finaly
  - 执行的方法中，先后又调用了另外的几个方法 abc，abc 递进关系，建议 abc 使用 thorws 处理，执行方法使用 try—catch—finaly
- 异常对象的产生
  - 系统自动生成的异常对象
  - 手动生成异常对象，并抛出 ：thorw new 异常类型
- 自定义异常类
  - 继承于现有的异常：RuntimeException、Exception
  - 提供全局常量： serialVersionUID
  - 提供重载构造器
- throw、throws 区别
  - throw
    - 抛出异常
    - 方法体内
    - 手动抛出
    - 生成异常对象
  - throws
    - 声明异常
    - 方法声明处
    - 捕获、抓
    - 异常处理的方式 

