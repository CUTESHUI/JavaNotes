## 枚举类和注解

#### 枚举类

- 类的对象只有有限个，确定的
  - 星期：Monday(星期一)、......、Sunday(星期天) 
  - 性别：Man(男)、Woman(女) 
  - 季节：Spring(春节)......Winter(冬天) 
  - 支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡) 
  - 就职状态：Busy、Free、Vocation、Dimission
  - 订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、Return（退货）、Checked（已确认）Fulfilled（已配货）
  - 线程状态：创建、就绪、运行、阻塞、死亡
- 当需要定义一组常量时，强烈建议使用枚举类

- 枚举类的实现
  - JDK1.5之前需要自定义枚举类
    - 声明对象的属性， private final
    - 私有化类的构造器，并给对象属性赋值
    - 提供类的多个对象，public static final
  - JDK 1.5 新增的 enum 关键字用于定义枚举类
    - 提供类的多个对象，对象之间用 “，“ 隔开，末尾的对象用 “ ；”
    - 声明对象的属性， private final
    - 私有化类的构造器，并给对象属性赋值

- 若枚举只有一个对象, 则可以作为一种单例模式的实现方式

- 枚举类的属性
  - 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰
  - 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值
  - 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数

- Enum 类
  - 主要方法
    - values( )：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值
    - valueOf( String str)
      1. 可以把一个字符串转为对应的枚举类对象
      2. 通过枚举类常量名返回枚举
      3. 要求字符串必须是枚举类对象的 “名字”。如不是，会有运行时异常：IllegalArgumentException
    - toString( )：返回当前枚举类对象常量的名称
- 和普通 Java 类一样，枚举类可以实现一个或多个接口
- 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可
- 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法



#### 注解

- Annotation

- 从 JDK 5.0 开始，Java 增加了对元数据(MetaData) 的支持，也就是Annotation(注解) 

- Annotation 其实就是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。

- 通过使用 Annotation，程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署

- Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在 Annotation 的 “name=value” 对中。

- 使用 Annotation 时要在其前面增加 @ 符号， 并把该 Annotation 当成一个修饰符使用

- 示例一：生成文档相关的注解

  - @author 标明开发该类模块的作者，多个作者之间使用,分割

  - @version 标明该类模块的版本

  - @see 参考转向，也就是相关主题

  - @since 从哪个版本开始增加的

  - @param 对方法中某参数的说明，如果没有参数就不能写

  - @return 对方法返回值的说明，如果方法的返回值类型是void就不能写

  - @exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写

    其中

    - @param @return 和 @exception 这三个标记都是只用于方法的。
    - @param的格式要求：@param 形参名 形参类型 形参说明
    - @return 的格式要求：@return 返回值类型 返回值说明
    - @exception的格式要求：@exception 异常类型 异常说明
    - @param和@exception可以并列多个

- 示例二：在编译时进行格式检查 ( JDK内置的三个基本注解 ) 

  - @Override: 限定重写父类方法，该注解只能用于方法
  - @Deprecated: 用于表示所修饰的元素(类、方法等)已过时
  - @SuppressWarnings: 抑制编译器警告

- 自定义注解
  - 定义新的 Annotation 类型使用 @interface 关键字
  - 自定义注解自动继承了java.lang.annotation.Annotation接口
  - Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明
  - 其方法名和返回值定义了该成员的名字和类型，称为配置参数
  - 类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组
  - 如果只有一个参数成员，建议使用参数名为value
  - 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字
  - 没有成员定义的 Annotation 称为标记，包含成员变量的 Annotation 称为元数据 Annotation

- 元注解

  - 对现有注解进行修饰的注解

  - JDK5.0提供了4个标准的meta-annotation类型，分别是

    - Retention
    - Target
    - Documented
    - Inherited

  - @Retention

    - 用于指定该 Annotation 的生命周期：SOURCE、CLASS、RUNTIME
    - @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值: 
      1. RetentionPolicy.SOURCE：在源文件中有效，编译器直接丢弃这种策略的注释
      2. RetentionPolicy.CLASS：在.class文件中有效， 当运行 Java 程序时，JVM 不会保留注解，这是默认值
      3. RetentionPolicy.RUNTIME：在运行时有效，当运行 Java 程序时， JVM 会保留注释，程序可以通过反射获取该注释

  - @Target

    - 用于指定被修饰的 Annotation，能用于修饰哪些结构
    - @Target 也包含一个名为 value 的成员变量
      - TYPE：类、接口
      - METHOD：方法
      - CONSTRUCTION：构造器
      - PACKAGE：包
      - LOCAL_VARIABLE：局部变量
      - FILED：作用域
      - PARAMETER：参数

  - @Documented

    - 用于指定被该元 Annotation 修饰的 Annotation 类，将被 javadoc 工具提取成文档
    - 默认情况下，javadoc是不包括注解的
    - 定义为 Documented 的注解必须设置 Retention 值为 RUNTIME

  - @Inherited

    - 被它修饰的 Annotation 将具有继承性
    - 如果某个类使用了被 @Inherited 修饰的 Annotation，则其子类将自动具有该注解

    - 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解

    - 实际应用中，使用较少

- Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解
  - 可重复注解
  - 可用于类型的注解